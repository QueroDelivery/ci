name: CI-K8-BASE

on:
  workflow_call:
    inputs:
      WF_IMAGE_TAG:
        type: string
        required: true
      WF_IMAGE_VERSION_TAG:
        type: string
        required: true
      WF_DIGEST_IMAGE:
        type: string
        required: true
      WF_ENV_TYPE_DEPLOY:
        type: string
        required: true
      WF_ENV_TYPE:
        type: string
        required: true
      WF_PUBLIC_HOST:
        type: string
        required: false
      WF_KUBE_MIN_REPLICAS:
        type: string
        required: true
      WF_KUBE_MAX_REPLICAS:
        type: string
        required: true
      WF_KUBE_MEMORY_LIMIT:
        type: string
        required: false
      WF_KUBE_MEMORY_REQUEST:
        type: string
        required: false
        default: 250Mi
      WF_KUBE_CPU_LIMIT:
        type: string
        required: false
      WF_KUBE_CPU_REQUEST:
        type: string
        required: false
        default: 85m
      WF_KUBE_NODE_GROUP:
        type: string
        required: true
      WF_KUBE_DEPLOYMENT:
        type: string
        required: true
      WF_SHOW_COMMENT:
        type: boolean
        required: false
      WF_CREATE_PR_IN_MAIN:
        type: boolean
        required: false
      WF_IS_INTERNAL:
        type: boolean
        required: false

    secrets:
      WF_KUBE_TYPE:
        required: true
      WF_AWS_ACCESS_KEY_ID:
        required: true
      WF_AWS_SECRET_ACCESS_KEY:
        required: true
      WF_AWS_REGION:
        required: true
      WF_SERVICE_NAME:
        required: true
      WF_KUBE_NAME:
        required: true
      WF_KUBE_DOMAIN:
        required: true
      WF_KUBE_DOMAIN_INTERNAL:
        required: true
      WF_GITHUB_TOKEN:
        required: true
      WF_WHITELIST_SOURCE_RANGE:
        required: false

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    environment: ${{ inputs.WF_ENV_TYPE_DEPLOY }}
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout kube manifests
        uses: actions/checkout@v4
        with:
          ref: v1.11.1
          token: ${{ secrets.WF_GITHUB_TOKEN }}
          repository: QueroDelivery/kube
          path: .kube
          persist-credentials: false

      - name: Setup AWS & IAM
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.WF_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.WF_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.WF_AWS_REGION }}
          role-session-name: ${{ secrets.WF_SERVICE_NAME }}_GitHubActions

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Override kubefiles
        run: |
          FILE=setup/.kube
          if [[ -d "$FILE" ]]; then
            echo "$FILE EXIST!" 
            cp -avf setup/.kube/*.yaml .kube/
            echo "Kubefiles Override FINISHED" 
          fi

      - name: Fetch environment from SSM
        uses: almerindo/action-env-from-aws-ssm@main
        with:
          output: ./.kube/${{ secrets.WF_KUBE_NAME }}-env-cm.yaml
          ssm-path: "/${{ inputs.WF_ENV_TYPE }}/${{ secrets.WF_SERVICE_NAME }}"
          format: configmap
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.WF_AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.WF_AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.WF_AWS_REGION }}

      - name: Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.30.6/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          curl -Lo aws-iam-authenticator https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.6.26/aws-iam-authenticator_0.6.26_linux_amd64
          chmod +x aws-iam-authenticator
          sudo mv aws-iam-authenticator /usr/local/bin/

      - name: Prepare envs
        run: |
          echo "WF_KUBE_MEMORY_LIMIT=${{ inputs.WF_KUBE_MEMORY_LIMIT || inputs.WF_KUBE_MEMORY_REQUEST }}" >> $GITHUB_ENV
      - name: Remove WF_KUBE_CPU_LIMIT when is null
        if: ${{inputs.WF_KUBE_CPU_LIMIT == ''}}
        run: |
          sed -i '/KUBE_CPU_LIMIT/d' ./.kube/deployment-new.yaml
      - name: Render manifests with envsubst
        env:
          KUBE_NAME: ${{ secrets.WF_KUBE_NAME }}
          KUBE_DOMAIN: ${{ secrets.WF_KUBE_DOMAIN }}
          KUBE_DOMAIN_INTERNAL: ${{ secrets.WF_KUBE_DOMAIN_INTERNAL }}
          KUBECONFIG: .kube/config-${{secrets.WF_KUBE_TYPE}}.yaml
          KUBEDEPLOYMENT: .kube/deployment-${{inputs.WF_KUBE_DEPLOYMENT}}.yaml
          KUBE_MIN_REPLICAS: ${{ inputs.WF_KUBE_MIN_REPLICAS }}
          PUBLIC_HOST: ${{ inputs.WF_PUBLIC_HOST }}
          KUBE_MAX_REPLICAS: ${{ inputs.WF_KUBE_MAX_REPLICAS }}
          KUBE_MEMORY_LIMIT: ${{ env.WF_KUBE_MEMORY_LIMIT }}
          KUBE_MEMORY_REQUEST: ${{ inputs.WF_KUBE_MEMORY_REQUEST }}
          KUBE_CPU_LIMIT: ${{ inputs.WF_KUBE_CPU_LIMIT }}
          KUBE_CPU_REQUEST: ${{ inputs.WF_KUBE_CPU_REQUEST }}
          KUBE_NODE_GROUP: ${{ inputs.WF_KUBE_NODE_GROUP }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: "${{ secrets.WF_SERVICE_NAME }}"
          VERSION_TAG: ${{ inputs.WF_IMAGE_VERSION_TAG }}
        run: |
          mkdir -p rendered
          for file in .kube/*.yaml; do
            envsubst < "$file" > "rendered/$(basename $file)"
          done
          cat rendered/namespace.yaml
      - name: Apply manifests
        env:
          KUBECONFIG: .kube/config-${{ secrets.WF_KUBE_TYPE }}.yaml
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: "${{ secrets.WF_SERVICE_NAME }}"
          VERSION_TAG: ${{ inputs.WF_IMAGE_VERSION_TAG }}
          KUBE_NAME: ${{ secrets.WF_KUBE_NAME }}
        run: |
          export PATH=$PATH:$PWD
          # Apply namespace manifest if it exists (kubectl apply will create it if it doesn't exist)
          if [ -f rendered/namespace.yaml ]; then
            echo "Applying namespace manifest..."
            kubectl apply -f rendered/namespace.yaml || {
              echo "Failed to apply namespace.yaml, creating namespace directly..."
              kubectl create namespace ${KUBE_NAME} || true
            }
          else
            echo "namespace.yaml not found, creating namespace directly..."
            kubectl create namespace ${KUBE_NAME} || true
          fi
          # Wait for namespace to be ready
          kubectl wait --for=condition=Active namespace/${KUBE_NAME} --timeout=30s || true
          # Verify namespace exists before applying ConfigMap
          if ! kubectl get namespace ${KUBE_NAME} &>/dev/null; then
            echo "ERROR: Namespace ${KUBE_NAME} still does not exist after creation attempt"
            exit 1
          fi
          # Apply ConfigMap with explicit namespace
          kubectl apply -f rendered/${KUBE_NAME}-env-cm.yaml -n ${KUBE_NAME}
          kubectl apply -f rendered/deployment-${{ inputs.WF_KUBE_DEPLOYMENT }}.yaml -n ${KUBE_NAME}
          DEPLOY_NAME=$(yq e '.metadata.name' rendered/deployment-${{ inputs.WF_KUBE_DEPLOYMENT }}.yaml)
          kubectl rollout restart deployment/$DEPLOY_NAME -n $KUBE_NAME
          kubectl rollout status deployment/$DEPLOY_NAME -n $KUBE_NAME
          kubectl apply -f rendered/hpa.yaml -n ${KUBE_NAME}
          kubectl apply -f rendered/service.yaml -n ${KUBE_NAME}
          kubectl apply -f rendered/ingress.yaml -n ${KUBE_NAME}
          kubectl apply -f rendered/ingress-internal.yaml -n ${KUBE_NAME}

      - name: Set service visibility (internal ingress whitelist)
        if: ${{ inputs.WF_IS_INTERNAL }}
        env:
          KUBECONFIG: .kube/config-${{ secrets.WF_KUBE_TYPE }}.yaml
          KUBE_NAME: ${{ secrets.WF_KUBE_NAME }}
          WHITELIST_SOURCE_RANGE: ${{ secrets.WF_WHITELIST_SOURCE_RANGE }}
        run: |
          kubectl -n ${KUBE_NAME} annotate --overwrite ingress ${KUBE_NAME} ingress.kubernetes.io/whitelist-source-range=${WHITELIST_SOURCE_RANGE}

      - name: Comment on PR with deployed image
        if: ${{ inputs.WF_SHOW_COMMENT }}
        env:
          GH_TOKEN: ${{ secrets.WF_GITHUB_TOKEN }}
          ECR_REPOSITORY: "${{ secrets.WF_SERVICE_NAME }}"
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body "âœ… Deployed image: \`${{ steps.login-ecr.outputs.registry }}/${ECR_REPOSITORY}:${{ inputs.WF_IMAGE_TAG }}\`"
          gh pr comment ${{ github.event.pull_request.number }} --body "Segura o link dessa app review aÃ­ Ã³ o/
            -   URL: https://${{ secrets.WF_KUBE_NAME }}${{ secrets.WF_KUBE_DOMAIN }}"

      - name: upsert .deploys/service.json
        env:
          IMAGE_DIGEST: ${{ inputs.WF_DIGEST_IMAGE }}
          FILE: .deploys/service.json
          ENV: "${{ inputs.WF_ENV_TYPE_DEPLOY }}"
          GITHUB_TOKEN: ${{ secrets.WF_GITHUB_TOKEN }}
          IMAGE_TAG: ${{ inputs.WF_IMAGE_TAG }}
          VERSION_TAG: "${{ inputs.WF_IMAGE_VERSION_TAG }}"
          BRANCH: deploy-state

        run: |
          # Setup Git identity
          git config user.name "github-actions"
          git config user.email "actions@github.com"

          # Worktree cleanup (idempotent)
          if [ -d "../deploy-worktree" ]; then
            echo "ðŸ§¹ Cleaning up existing worktree"
            git worktree remove --force ../deploy-worktree || true
          fi

          # Ensure remote branch exists or create from main
          if ! git show-ref --verify --quiet refs/remotes/origin/$BRANCH; then
            echo "ðŸ†• Branch '$BRANCH' does not exist remotely. Creating it from main."
            git fetch origin main
            
            # Check if local branch exists and delete it if it does
            if git show-ref --verify --quiet refs/heads/$BRANCH; then
              echo "ðŸ—‘ï¸ Removing existing local branch '$BRANCH'"
              git branch -D "$BRANCH"
            fi
            
            git branch "$BRANCH" origin/main
            git push origin $BRANCH
          else
            git fetch origin $BRANCH
          fi

          # Create worktree pointing to the branch
          git worktree add ../deploy-worktree $BRANCH

          # Prepare local source file for upsert based on branch content
          mkdir -p "$(dirname "$FILE")"
          if [ -f "../deploy-worktree/$FILE" ]; then
            echo "ðŸ“„ Loading existing $FILE from branch"
            cp "../deploy-worktree/$FILE" "$FILE"
          else
            echo "ðŸ†• Initializing $FILE with empty object"
            echo "{}" > "$FILE"
          fi

          # Upsert new environment entry into the file
          jq --arg env "$ENV" \
            --arg digest "$IMAGE_DIGEST" \
            --arg version_tag "$VERSION_TAG" \
            --arg image_tag "$IMAGE_TAG" \
            '. + {($env): {digest: $digest, version_tag: $version_tag, image_tag: $image_tag}}' \
            "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"

          # Copy updated file into the worktree
          mkdir -p "$(dirname ../deploy-worktree/$FILE)"
          cp "$FILE" ../deploy-worktree/$FILE

      - name: Handle dev layer vs tracked environments
        if: ${{ inputs.WF_ENV_TYPE_DEPLOY == 'dev' }}
        uses: actions/upload-artifact@v4
        with:
          name: service-${{ secrets.WF_SERVICE_NAME }}-dev-${{ github.event.pull_request.number || github.sha }}
          path: .deploys/service.json

      - name: Commit & Push deploy state (stg/prod)
        if: ${{ inputs.WF_ENV_TYPE_DEPLOY != 'dev' }}
        env:
          BRANCH: "deploy-state"
          ENV: "${{ inputs.WF_ENV_TYPE_DEPLOY }}"
          FILE: ".deploys/service.json"
        run: |
          # Setup Git identity
          git config user.name "github-actions"
          git config user.email "actions@github.com"

          # Remove worktree if already exists (idempotency)
          if [ -d "../deploy-worktree" ]; then
            echo "ðŸ§¹ Cleaning up existing worktree"
            git worktree remove --force ../deploy-worktree || true
          fi

          # Fetch latest remote branch (guaranteed to exist from previous step)
          git fetch origin $BRANCH

          # Add isolated worktree for that branch
          git worktree add ../deploy-worktree $BRANCH

          # Ensure destination directory exists
          mkdir -p "$(dirname ../deploy-worktree/$FILE)"

          # Copy generated .deploys/service.json into worktree
          cp "$FILE" ../deploy-worktree/$FILE

          # Commit and push if there are changes
          cd ../deploy-worktree
          git add "$FILE"
          if git commit -m "chore(ci): promote to $ENV [skip ci]"; then
            # Rebase to preserve remote history
            git pull --rebase origin $BRANCH
            git push origin HEAD:$BRANCH
          else
            echo "âš ï¸ Nothing to commit"
          fi

      - name: Check if there are commits between staging to main
        id: check_commits
        if: ${{ inputs.WF_CREATE_PR_IN_MAIN}}
        run: |
          if [ "$(git rev-list --count 'origin/main..HEAD')" -eq 0 ]; then
            echo "No commits to create pull request for."
            echo "commits_head_main=false" >> $GITHUB_OUTPUT
          else
            echo "Commits found. Ready to create pull request."
            echo "commits_head_main=true" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request for prod
        if: ${{ inputs.WF_CREATE_PR_IN_MAIN && steps.check_commits.outputs.commits_head_main == 'true'}}
        id: "open-pr"
        env:
          GH_TOKEN: ${{ secrets.WF_GITHUB_TOKEN }}
        run: |
          echo "Creating the PR Deply in prod"
          gh pr edit stage -b "Pull request body" -t 'Deploy in prod'  && gh pr reopen stage || gh pr create --base "main" --title "Deploy in prod" --body "Pull request body"
